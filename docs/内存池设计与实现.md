什么是内存池

c/c++ 中程序员有时需要动态地申请和释放内存空间，这部分内存空间在堆区。默认的方式分别是 malloc，free，new，delete。然而频繁地在堆上分配和释放内存，会导致性能的损失，产生大量的内存碎片。因此很多时候会根据业务需要设计专用的内存管理器，便于针对特定的数据结构和使用场合进行内存管理。内存池就是这样一种技术，它是一种更有效率的内存管理方案。

内存池的原理

它的实现思想是，在真正使用内存池中管理的内存之前，预先申请分配一定数量，大小预设的内存块留作备用。当有内存需求时，就从内存池中分出一部分内存块给程序使用。若内存块不够再继续向系统申请新的内存放在内存池中，当内存释放后就将内存块回收留作后续的复用。这样的方式可以使得内存使用效率提升，减少产生内存碎片的可能性。同时，内存池对于内存空间的管理是在用户空间进行的，避免了系统调用带来的切换到内核态的系统开销。

 内存池的使用场景

比如在服务端，每次用户申请需要创建的对象可能就那几种，我们可以在自己的内存池上提前创建出这些对象，当业务逻辑需要时就从内存池中申请已经创建好的对象，使用完毕后还回内存池。

内存碎片的解决方案：

内存随便分为内部碎片和外部碎片：

1.   内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就产生了内部碎片，通常内部碎片难以避免。
2.   外部碎片式由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配需求，从而不能被进程利用的内存区域。

段页式内存将内存分为不同的段，每段分为多个固定大小的页。通过页表机制，使得段内的页可以不是连续的，这种方式减少了外部碎片。然而内部碎片不可避免，但是页表较小，内部碎片可以忽略。内存池根据固定的数据结构设计内存块大小，可以优化减少内部碎片。

经典的内存池的设计

1.   先向系统申请一块连续的内存空间，该段内存能容纳一定数量的对象

2.   每个对象连同下一个对象的指针一起构成内存结点。各个空闲的结点通过指针形成一个链表，链表的每一个内存结点都是一个可供分配的内存空间。
3.   某个内存结点一旦分配出去，从空闲链表中去除
4.   一旦释放了某个内存结点，有将该结点重新加入空闲内存结点链表
5.   如果一个内存块的所有结点分配完毕，若程序继续申请新的对象空间，则会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。

**内存分级如何实现**



